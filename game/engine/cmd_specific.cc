// Copyright (c) Facebook, Inc. and its affiliates.
// All rights reserved.
//
// This source code is licensed under the license found in the
// LICENSE file in the root directory of this source tree.
//
#include "cmd.h"
#include "cmd_receiver.h"
#include "game_env.h"
#include "utils.h"

// Derived class. Note that the definition is automatically generated by a
// python file.
#include "cmd.gen.h"
#include "cmd.h"
#include "cmd_specific.gen.h"

// #include "aux_func.h"
#include "engine/lua/cpp_interface.h"

// TODO: change to enum class
static const int kMoveToRes = 0;
static const int kGathering = 1;
static const int kMoveToTownHall = 2;

static const int kMakeTemporary = 0;
static const int kMoveToDest = 1;
static const int kBuilding = 3;

static constexpr float kGatherDist = 1;
static constexpr float kBuildDist = 1;

static constexpr float kGatherDistSqr = kGatherDist * kGatherDist;
static constexpr float kBuildDistSqr = kBuildDist * kBuildDist;

/*
CMD_DURATIVE(Attack, UnitId, target);
    Durative attack. Will first move to target until in attack range. Then it
    issues melee attack if melee, and emits a bullet if ranged. This will resut
in a
    default counterattack by target.
CMD_DURATIVE(Move, PointF, p);
    Durative move to a point p.
CMD_DURATIVE(Build, UnitType, build_type, PointF, p=PointF(), int, state=0);
    Move to point p to build a unit of build_type. Also changes resource
    if necessary.
CMD_DURATIVE(Gather, UnitId, base, UnitId, resource, int, state=0);
    Move between base and resources to gather resources.
*/

//////////// Durative Action ///////////////////////
bool CmdMove::run(const GameEnv& env, CmdReceiver* receiver) {
  assert(env.IsGameActive());

  const Unit* u = env.GetUnit(_id);
  if (u == nullptr) {
    return false;
  }
  if (micro_move(_tick, *u, env, _p, receiver) < kDistEps) {
    _done = true;
  }
  return true;
}

bool CmdMove::cleanup(const GameEnv&, CmdReceiver*) {
  return true;
}

// ----- Attack
// Attack cmd.target_id
bool CmdAttack::run(const GameEnv& env, CmdReceiver* receiver) {
  assert(env.IsGameActive());

  const Unit* u = env.GetUnit(_id);
  if (u == nullptr) {
    return false;
  }

  const Unit* target = env.GetUnit(_target);
  const Player& player = env.GetPlayer(u->GetPlayerId());
  if (target == nullptr || !player.FilterWithFOW(*target, true)) {
    // (player.GetPrivilege() == PV_NORMAL &&
    //  !player.FilterWithFOW(*target, true))) {
    // The goal is destroyed or is out of FOW, back to idle.
    // FilterWithFOW is checked if the agent is not a KNOW_ALL agent.
    // For example, for AI, they could cheat and attack wherever they want.
    // For normal player you cannot attack a Unit outside the FOW unless you
    // have previous seen it.
    // if (target != nullptr && !player.FilterWithFOW(*target, true)) {
    //   receiver->SendCmd(CmdDPtr(new CmdMove(_id, target->GetPointF())));
    // }
    _done = true;
    return true;
  }

  const UnitProperty& property = u->GetProperty();
  const auto& unit_template = env.GetGameDef().unit(u->GetUnitType());
  const float attack_mult =
      unit_template.GetAttackMultiplier(target->GetUnitType());
  const int damage = static_cast<int>(property._att * attack_mult);
  if (damage == 0) {
    _done = true;
    return true;
  }

  const PointF& curr = u->GetPointF();
  const PointF& target_p = target->GetPointF();

  int dist_sqr_to_enemy = PointF::L2Sqr(curr, target_p);
  bool in_attack_range =
      (dist_sqr_to_enemy <= property._att_r * property._att_r);

  // Otherwise attack.
  if (property.CD(CD_ATTACK).Passed(_tick) && in_attack_range) {
    // Melee delivers attack immediately, long-range will deliver attack via
    // bullet.
    if (property._att_r <= 1.0) {
      receiver->SendCmd(CmdIPtr(new CmdMeleeAttack(_id, _target, -damage)));
    } else {
      receiver->SendCmd(
          CmdIPtr(new CmdEmitBullet(_id, _target, curr, -damage, 0.2)));
    }
    receiver->SendCmd(CmdIPtr(new CmdCDStart(_id, CD_ATTACK)));
  } else if (!in_attack_range) {
    micro_move(_tick, *u, env, target_p, receiver);
  }

  // In both case, continue this action.
  return true;
}

bool CmdAttack::cleanup(const GameEnv&, CmdReceiver*) {
  return true;
}

// ---- Gather
bool CmdGather::run(const GameEnv& env, CmdReceiver* receiver) {
  assert(env.IsGameActive());

  const Unit* u = env.GetUnit(_id);
  if (u == nullptr)
    return false;

  // Gather resources back and forth.
  const Unit* resource = env.GetUnit(_resource);
  const Unit* town_hall = env.GetUnit(_town_hall);
  if (resource == nullptr || town_hall == nullptr) {
    // Either resource or town_hall is gone. so we stop.
    _done = true;
    return false;
  }
  // const RTSMap &m = env.GetMap();
  // const PointF &curr = u->GetPointF();
  const UnitProperty& property = u->GetProperty();
  const PointF& res_p = resource->GetPointF();
  const PointF& town_hall_p = town_hall->GetPointF();

  //  cout << "[" << tick << "] [" << cmd_state.state << "]" << " CD_MOVE: "
  //       << property.CD(CD_MOVE).PrintInfo(tick) << "  CD_GATHER: "
  //       << property.CD(CD_GATHER).PrintInfo(tick) << endl;
  switch (_state) {
  case kMoveToRes:
    if (micro_move(_tick, *u, env, res_p, receiver) < kGatherDistSqr) {
      // Switch
      receiver->SendCmd(CmdIPtr(new CmdCDStart(_id, CD_GATHER)));
      _state = kGathering;
    }
    break;
  case kGathering:
    // Stay for gathering.
    if (property.CD(CD_GATHER).Passed(_tick)) {
      receiver->SendCmd(CmdIPtr(new CmdHarvest(_id, _resource, -10)));
      _state = kMoveToTownHall;
    }
    break;
  case kMoveToTownHall:
    // Get the location of closest town_hall.
    if (micro_move(_tick, *u, env, town_hall_p, receiver) < kGatherDistSqr) {
      // Switch
      receiver->SendCmd(CmdIPtr(
          new CmdChangePlayerResource(_id, u->GetPlayerId(), 10 * _scale)));
      _state = kMoveToRes;
    }
    break;
  }
  return true;
}

bool CmdGather::cleanup(const GameEnv&, CmdReceiver*) {
  return true;
}

bool CmdBuild::run(const GameEnv& env, CmdReceiver* receiver) {
  assert(env.IsGameActive());

  const Unit* u = env.GetUnit(_id);
  assert(u != nullptr);  // should be checked in GameState::forward
  // if (u == nullptr) {
  //   return false;
  // }
  const PointF& curr = u->GetPointF();
  const UnitProperty& prop = u->GetProperty();
  auto player_id = u->GetPlayerId();
  int cost = env.GetGameDef().unit(_build_type).GetUnitCost();
  int cooldown = prop.CD(CD_BUILD)._cd;

  if (!_money_deducted) {
    const Player& player = env.GetPlayer(player_id);
    int resource = player.GetResource();
    if (cost > resource) {
      std::cout << "Error: cannot afford building, this should not happen"
                << std::endl;
      // assert(false);
    }

    auto cmd = CmdIPtr(new CmdChangePlayerResource(_id, player_id, -cost));
    receiver->SendCmd(std::move(cmd));
    _money_deducted = true;
  }

  // When cmd.p = INVALID, build nearby.
  // Otherwise move to nearby location of cmd.p and build at cmd.p
  if (_state == kMakeTemporary) {
    if (GameDef::IsUnitTypeBuilding(_build_type)) {
      assert(_p.IsValid());
      const bool can_build = env.GetMap().CanPass(
          _p, INVALID, true, env.GetGameDef().unit(_build_type));

      if (!can_build) {
        // cannot build here, money back, end
        auto cmd = CmdIPtr(new CmdChangePlayerResource(_id, player_id, cost));
        receiver->SendCmd(std::move(cmd));
        _done = true;
        return true;
      }

      auto cmd = CmdIPtr(new CmdCreate(
          _id, _build_type, _p, u->GetPlayerId(), cost, 10000000));
      receiver->SendCmd(std::move(cmd));
    }
    _state = kMoveToDest;
  } else if (_state == kMoveToDest) {
    if (_p.IsInvalid() || PointF::L2Sqr(curr, _p) < kBuildDistSqr) {
      receiver->SendCmd(CmdIPtr(new CmdCDStart(_id, CD_BUILD)));

      if (GameDef::IsUnitTypeBuilding(_build_type)) {
        auto cmd = CmdIPtr(
            new CmdCreate(_id, _build_type, _p, player_id, cost, cooldown));
        receiver->SendCmd(std::move(cmd));
      }
      _state = kBuilding;
    } else {
      // Move to nearby location.
      PointF nearby_p;
      if (find_nearby_empty_place(env, *u, _p, &nearby_p)) {
        micro_move(_tick, *u, env, _p, receiver);
      }
    }
  } else if (_state == kBuilding) {
    // Stay for building.
    if (prop.CD(CD_BUILD).Passed(_tick)) {
      PointF build_p;
      if (_p.IsInvalid()) {
        build_p.SetInvalid();
        find_nearby_empty_place(env, *u, curr, &build_p);
      } else {
        build_p = _p;
      }

      if (!build_p.IsInvalid()) {
        auto cmd =
            CmdIPtr(new CmdCreate(_id, _build_type, build_p, player_id, cost));
        receiver->SendCmd(std::move(cmd));
        _done = true;
      }
    }
  }
  return true;
}

bool CmdBuild::cleanup(const GameEnv& env, CmdReceiver* receiver) {
  const Unit* u = env.GetUnit(_id);
  if (u == nullptr) {
    return false;
  }
  const int cost = env.GetGameDef().unit(_build_type).GetUnitCost();
  if (_money_deducted) {
    receiver->SendCmd(
        CmdIPtr(new CmdChangePlayerResource(_id, u->GetPlayerId(), cost)));
  }

  // TODO: fix it
  if (GameDef::IsUnitTypeBuilding(_build_type)) {
    GameEnv* env_ = const_cast<GameEnv*>(&env);
    RemoveTemporaryBuilding(_p, _build_type, u->GetPlayerId(), env_, receiver);
  }
  return true;
}

bool CmdMeleeAttack::run(GameEnv* env, CmdReceiver* receiver) {
  assert(env->IsGameActive());

  Unit* target = env->GetUnit(_target);
  if (target == nullptr) {
    return true;
  }

  UnitProperty& p_target = target->GetProperty();
  if (p_target.IsDead())
    return true;

  const auto& target_tp = env->GetGameDef().unit(target->GetUnitType());

  int changed_hp = _att;
  if (changed_hp < 0) {
    changed_hp += p_target._def;
    if (changed_hp > 0) {
      changed_hp = 0;
    }
  }

  p_target._hp += changed_hp;
  if (p_target.IsDead()) {
    receiver->SendCmd(CmdIPtr(new CmdOnDeadUnit(_id, _target)));
  } else if (changed_hp < 0) {
    p_target._changed_hp = changed_hp;
    p_target._damage_from = _id;
    if (receiver->GetUnitDurativeCmd(_target) == nullptr &&
        target_tp.CmdAllowed(ATTACK)) {
      // Counter attack.
      receiver->SendCmd(CmdDPtr(new CmdAttack(_target, _id)));
    }
  }
  return true;
}

bool CmdChangePlayerResource::run(GameEnv* env, CmdReceiver* receiver) {
  assert(env->IsGameActive());

  Player& player = env->GetPlayer(_player_id);
  int curr_resource = player.ChangeResource(_delta);
  if (curr_resource < 0) {
    // Change it back and cancel the durative command of _id.
    // cout << "Cancel the build from " << _id << " amount " << _delta
    //      << "player_id " << _player_id << endl;
    player.ChangeResource(-_delta);
    receiver->FinishDurativeCmd(_id);
    return false;
  }
  return true;
}

bool CmdIssueInstruction::run(GameEnv* env, CmdReceiver*) {
  auto& player = env->GetPlayer(_player_id);
  player.IssueInstruction(_tick, _instruction);
  if (_change_state) {
    // auto& player = env->GetPlayer(_player_id);
    // player.IssueInstruction(_tick, _instruction);
    env->ChangeGameStatus(WAITING_STATUS);
  }
  return true;
}

bool CmdAcceptInstruction::run(GameEnv* env, CmdReceiver*) {
  env->ChangeGameStatus(ACTIVE_STATUS);
  return true;
}

bool CmdWarnInstruction::run(GameEnv* env, CmdReceiver*) {
  auto& player = env->GetPlayer(_player_id);
  player.WarnInstruction();
  return true;
}

bool CmdFinishInstruction::run(GameEnv* env, CmdReceiver*) {
  auto& player = env->GetPlayer(_player_id);
  player.FinishInstruction(_tick);
  env->ChangeGameStatus(FROZEN_STATUS);
  return true;
}

bool CmdInterruptInstruction::run(GameEnv* env, CmdReceiver*) {
  auto& player = env->GetPlayer(_player_id);
  player.FinishInstruction(_tick);
  env->ChangeGameStatus(FROZEN_STATUS);
  return true;
}

bool CmdOnDeadUnit::run(GameEnv* env, CmdReceiver* receiver) {
  assert(env->IsGameActive());
  env->GetGameDef().CmdOnDeadUnitImpl(env, receiver, _id, _target);
  return true;
}

// For gathering.
bool CmdHarvest::run(GameEnv* env, CmdReceiver* receiver) {
  assert(env->IsGameActive());
  Unit* target = env->GetUnit(_target);
  if (target == nullptr) {
    return false;
  }

  UnitProperty& p_target = target->GetProperty();
  if (p_target.IsDead()) {
    return false;
  }

  p_target._hp += _delta;
  if (p_target.IsDead()) {
    receiver->SendCmd(CmdIPtr(new CmdRemove(_target)));
  }
  return true;
}
